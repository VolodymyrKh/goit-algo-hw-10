# Порівняння алгоритмів

## Жадібний алгоритм (find_coins_greedy)

- Обирає найбільший можливий номінал на кожному кроці.  
- Часова складність: **O(n)**, де *n* – кількість типів монет.    
- Але він не завжди гарантує мінімальну кількість монет (наприклад, у випадку з "екзотичними" номіналами, як [4, 3, 1], сума 6 → жадібний вибере {4,1,1}, тоді як оптимальне рішення {3,3}).  
- У наборі монет [50, 25, 10, 5, 2, 1] він завжди дає оптимальне рішення, тому жадібному алгоритму надамо перевагу.

---

## Динамічне програмування (find_min_coins)

- Перебирає всі можливі варіанти розбиття суми, обираючи оптимальний.  
- Часова складність: **O(change × n)**, де *change* – решта, яку треба розбити за номіналами монет, а *n* – кількість номіналів.  
- Завжди знаходить мінімальну кількість монет незалежно від набору номіналів.  
- Мінус – більш повільний при великих сумах, бо потребує пропорційно більше обчислень і пам’яті.  

---

## Висновок

- Якщо набір монет "канонічний" (як у реальних валютах – 1, 2, 5, 10, 25, 50), то жадібний алгоритм працює швидко й завжди оптимально.  
- Якщо набір монет довільний, то жадібний підхід може дати неправильне рішення, тоді потрібен алгоритм динамічного програмування.  
- У нашій задачі касового апарату жадібний алгоритм — найкращий вибір через швидкість і правильність на стандартному наборі монет.

---

# Метод Монте-Карло

- Метод Монте-Карло дав інтеграл близький до аналітичного.
- Похибка оцінки зменшується при збільшенні кількості випадкових точок N.
- Метод ефективний для довільних функцій, де складно або неможливо знайти аналітичний інтеграл.
- Використання автоматичного визначення f_max робить алгоритм універсальним і незалежним від конкретної функції.

## Висновок
- Метод Монте-Карло дозволяє оцінювати інтеграли функцій із довільним видом, і його точність можна покращити шляхом збільшення кількості випадкових точок. - Порівняння з аналітичним інтегралом підтверджує правильність реалізації.
